//**********************************************************************
//
// This skeleton was generated by abvkit at 2016-08-24 15:58:13 GMT
// from grammar '/home/tondy/dev/abvkit/grammars/C.peg'.
//
//**********************************************************************

package ;

class CSemantics extends ParserBase.SemanticsBase {

//----------------------------------------------------------------------
//  Typedef table
//----------------------------------------------------------------------

  var typedefs:Array<String>;
  
  public function new()
  {
    super();
  }
  
	function arrayValue<T>(i:Int)
	{ 
		var r:Array<T> = null;
		try{
			r = new Array<T>();
			var a = cast(rhs(i).get(),Array<Dynamic>); 
			for (i in 0...a.length){
				if (a[i] != null)r[i] = cast a[i];
			}
		}catch(e:Dynamic){}; 
		return r;
	} 
	 
	function stringValue(i:Int)
	{ 
		return Std.string(rhs(i).get()); 
	}

  //-------------------------------------------------------------------
  // Invoked at the beginning of each invocation of the Parser.
  //-------------------------------------------------------------------
  public override function init()
  {
    super.init();
    typedefs = new Array<String>();
  }
  //-------------------------------------------------------------------
  // Declaration = DeclarationSpecifiers InitDeclaratorList? SEMI
  //-------------------------------------------------------------------
  public function Declaration()
  {
      // If InitDeclaratorList is present and DeclarationSpecifiers
      // contain "typedef", copy all Identifiers delivered
      // by InitDeclaratorList into typedefs table.

      if ((rhsSize() == 1) || (rhs(0).get() == null)) return;
      var iList:Array<String> = arrayValue(1);
      if (iList == null) {trace("err");return;}
      for (s in iList){
          if (typedefs.indexOf(s) == -1)typedefs.push(s);
	  }
  }
  
  //-------------------------------------------------------------------
  // DeclarationSpecifiers = (StorageClassSpecifier / TypeQualifier /
  // FunctionSpecifier)* TypedefName (StorageClassSpecifier /
  // TypeQualifier / FunctionSpecifier)*
  // DeclarationSpecifiers = (StorageClassSpecifier / TypeSpecifier /
  // TypeQualifier / FunctionSpecifier)+
  //-------------------------------------------------------------------
  public function DeclarationSpecifiers()
  {
      // This semantic action is called by both alternatives
      // of DeclarationSpecifiers.
      // Scan all Specifiers and return semantic value "typedef"
      // if any of them is "typedef".

      lhs().put(null);
      for (i in 0...rhsSize()){
        if ((rhs(i).text().length >= 7)
            && (rhs(i).text().substring(0,7) == "typedef"))
        {
          lhs().put("typedef");
          return;
        }
	  }
  }
  
  //-------------------------------------------------------------------
  // InitDeclaratorList = InitDeclarator (COMMA InitDeclarator)*
  //-------------------------------------------------------------------
  public function InitDeclaratorList()
  {
      // Build Vector of Identifiers delivered by InitDeclarators
      // and return it as semantic value.

      var iList = new Array<String>();
      var i = 0;
      while (i < rhsSize()){
        iList.push(stringValue(i));
        i += 2;
	  }
      lhs().put(iList);
  }
  
  //-------------------------------------------------------------------
  // InitDeclarator = Declarator (EQU Initializer)?
  //-------------------------------------------------------------------
  public function InitDeclarator()
  {
      // Return as semantic value the Identifier delivered by Declarator.
      lhs().put(rhs(0).get());
  }
  
  //-------------------------------------------------------------------
  // Declarator = Pointer? DirectDeclarator
  //-------------------------------------------------------------------
  public function Declarator()
  {
      // Return as semantic value the Identifier delivered
      // by DirectDeclarator.

      lhs().put(rhs(rhsSize()-1).get());
  }
  
  //-------------------------------------------------------------------
  // DirectDeclarator = (Identifier / LPAR Declarator RPAR) (LBRK
  // TypeQualifier* AssignmentExpression? RBRK / LBRK STATIC
  // TypeQualifier* AssignmentExpression RBRK / LBRK TypeQualifier+
  // STATIC AssignmentExpression RBRK / LBRK TypeQualifier* STAR
  // RBRK / LPAR ParameterTypeList RPAR / LPAR IdentifierList?
  // RPAR)*
  //-------------------------------------------------------------------
  public function DirectDeclarator()
  {
      // Return as semantic value either the Identifier appearing on the rhs,
      // or the Identifier delivered by DirectDeclarator.

      if (rhs(0).isA("LPAR")) lhs().put(rhs(1).get());
      else lhs().put(rhs(0).get());
  }
  
  //-------------------------------------------------------------------
  // TypedefName = Identifier
  //-------------------------------------------------------------------
  public function TypedefName()
  { 
      // Return true if the Identifier appears in the typedefs table;
      // otherwise return false.

      return typedefs.indexOf(stringValue(0)) != - 1;
  }
  
  //-------------------------------------------------------------------
  // Identifier = !Keyword IdNondigit IdChar* Spacing
  //-------------------------------------------------------------------
  public function Identifier()
  {
      // Return as semantic value the String specified as Identifier.

      lhs().put(rhsText(0,rhsSize()-1));
  }
  
}
