//**********************************************************************
//
// This file was generated by abvkit at 2016-08-23 16:40:37 GMT
// from grammar '/home/tondy/dev/abvkit/grammars/grammar.peg'.
//
//**********************************************************************

package abv.peg;

import abv.peg.ParserBase.Source;

@:dce
class Parser extends ParserBase{

  public var sem(default,null):Semantics;
  public var version(default,never) = 20160823.164037;
  public var kind(default,never) = "norm";
  public var grammar(default,never) = "grammar.peg";
  
  public function new()
  {
    super();
    sem = new Semantics();
    sem.rule = this;
  }
  
  public override function setTrace(s:String)
  {
    super.setTrace(s);
    sem.trc = s;
  }
  //-------------------------------------------------------------------
  // Run the parser
  //-------------------------------------------------------------------
  public function parse(src:Source)
  {
    init(src);
    sem.init();
    var result = Grammar();
    closeParser(result);
    return result;
  }
  
  //**********************************************************************
  //
  // Parsing procedures
  //
  //**********************************************************************
  //*********************************************************************
  // Grammar = Space (Rule / Skip)*+ EOT {Grammar} ;
  //*********************************************************************
  function Grammar()
  {
    begin("Grammar");
    Space();
    while (!EOT()){
      if (!Grammar_0()) return reject();
    }
    sem.Grammar();
    return accept();
  }
  
  //-------------------------------------------------------------------
  // Grammar_0 = Rule / Skip
  //-------------------------------------------------------------------
  function Grammar_0()
  {
    begin("");
    if (Rule()) return acceptInner();
    if (Skip()) return acceptInner();
    return rejectInner();
  }
  
  //*********************************************************************
  // Rule = Name EQUAL RuleRhs DiagName? SEMI {Rule} ~{Error} ;
  //*********************************************************************
  function Rule()
  {
    begin("Rule");
    if (Rule_0())
    { sem.Rule(); return accept(); }
    sem.Error();
    return reject();
  }
  
  //-------------------------------------------------------------------
  // Rule_0 = Name EQUAL RuleRhs DiagName? SEMI
  //-------------------------------------------------------------------
  function Rule_0()
  {
    begin("");
    if (!Name()) return rejectInner();
    if (!EQUAL()) return rejectInner();
    if (!RuleRhs()) return rejectInner();
    DiagName();
    if (!SEMI()) return rejectInner();
    return acceptInner();
  }
  
  //*********************************************************************
  // Skip = SEMI / _++ (SEMI / EOT) ;
  //*********************************************************************
  function Skip()
  {
    begin("Skip");
    if (SEMI()) return accept();
    if (Skip_0()) return accept();
    return reject();
  }
  
  //-------------------------------------------------------------------
  // Skip_0 = _++ (SEMI / EOT)
  //-------------------------------------------------------------------
  function Skip_0()
  {
    begin("");
    if (Skip_1()) return rejectInner();
    do{
      if (!next()) return rejectInner();
    }while (!Skip_1());
    return acceptInner();
  }
  
  //-------------------------------------------------------------------
  // Skip_1 = SEMI / EOT
  //-------------------------------------------------------------------
  function Skip_1()
  {
    begin("");
    if (SEMI()) return acceptInner();
    if (EOT()) return acceptInner();
    return rejectInner();
  }
  
  //*********************************************************************
  // RuleRhs = Sequence Actions (SLASH Sequence Actions)* {RuleRhs}
  // <right-hand side> ;
  //*********************************************************************
  function RuleRhs()
  {
    begin("RuleRhs","right-hand side");
    if (!Sequence()) return reject();
    Actions();
    while (RuleRhs_0()){ };
    sem.RuleRhs();
    return accept();
  }
  
  //-------------------------------------------------------------------
  // RuleRhs_0 = SLASH Sequence Actions
  //-------------------------------------------------------------------
  function RuleRhs_0()
  {
    begin("");
    if (!SLASH()) return rejectInner();
    if (!Sequence()) return rejectInner();
    Actions();
    return acceptInner();
  }
  
  //*********************************************************************
  // Choice = Sequence (SLASH Sequence)* {Choice} ;
  //*********************************************************************
  function Choice()
  {
    begin("Choice");
    if (!Sequence()) return reject();
    while (Choice_0()){ };
    sem.Choice();
    return accept();
  }
  
  //-------------------------------------------------------------------
  // Choice_0 = SLASH Sequence
  //-------------------------------------------------------------------
  function Choice_0()
  {
    begin("");
    if (!SLASH()) return rejectInner();
    if (!Sequence()) return rejectInner();
    return acceptInner();
  }
  
  //*********************************************************************
  // Sequence = Prefixed+ {Sequence} ;
  //*********************************************************************
  function Sequence()
  {
    begin("Sequence");
    if (!Prefixed()) return reject();
    while (Prefixed()){ };
    sem.Sequence();
    return accept();
  }
  
  //*********************************************************************
  // Prefixed = PREFIX? Suffixed {Prefixed} ;
  //*********************************************************************
  function Prefixed()
  {
    begin("Prefixed");
    PREFIX();
    if (!Suffixed()) return reject();
    sem.Prefixed();
    return accept();
  }
  
  //*********************************************************************
  // Suffixed = Primary (UNTIL Primary / SUFFIX)? {Suffixed} ;
  //*********************************************************************
  function Suffixed()
  {
    begin("Suffixed");
    if (!Primary()) return reject();
    Suffixed_0();
    sem.Suffixed();
    return accept();
  }
  
  //-------------------------------------------------------------------
  // Suffixed_0 = UNTIL Primary / SUFFIX
  //-------------------------------------------------------------------
  function Suffixed_0()
  {
    begin("");
    if (Suffixed_1()) return acceptInner();
    if (SUFFIX()) return acceptInner();
    return rejectInner();
  }
  
  //-------------------------------------------------------------------
  // Suffixed_1 = UNTIL Primary
  //-------------------------------------------------------------------
  function Suffixed_1()
  {
    begin("");
    if (!UNTIL()) return rejectInner();
    if (!Primary()) return rejectInner();
    return acceptInner();
  }
  
  //*********************************************************************
  // Primary = Name {Resolve} / LPAREN Choice RPAREN {Pass2} / ANY {Any}
  // / StringLit {Pass} / Range {Pass} / CharClass {Pass} ;
  //*********************************************************************
  function Primary()
  {
    begin("Primary");
    if (Name())
    { sem.Resolve(); return accept(); }
    if (Primary_0())
    { sem.Pass2(); return accept(); }
    if (ANY())
    { sem.Any(); return accept(); }
    if (StringLit())
    { sem.Pass(); return accept(); }
    if (Range())
    { sem.Pass(); return accept(); }
    if (CharClass())
    { sem.Pass(); return accept(); }
    return reject();
  }
  
  //-------------------------------------------------------------------
  // Primary_0 = LPAREN Choice RPAREN
  //-------------------------------------------------------------------
  function Primary_0()
  {
    begin("");
    if (!LPAREN()) return rejectInner();
    if (!Choice()) return rejectInner();
    if (!RPAREN()) return rejectInner();
    return acceptInner();
  }
  
  //*********************************************************************
  // Actions = OnSucc OnFail {Actions} ;
  //*********************************************************************
  function Actions()
  {
    begin("Actions");
    OnSucc();
    OnFail();
    sem.Actions();
    return accept();
  }
  
  //*********************************************************************
  // OnSucc = (LWING AND? Name? RWING)? {OnSucc} ;
  //*********************************************************************
  function OnSucc()
  {
    begin("OnSucc");
    OnSucc_0();
    sem.OnSucc();
    return accept();
  }
  
  //-------------------------------------------------------------------
  // OnSucc_0 = LWING AND? Name? RWING
  //-------------------------------------------------------------------
  function OnSucc_0()
  {
    begin("");
    if (!LWING()) return rejectInner();
    AND();
    Name();
    if (!RWING()) return rejectInner();
    return acceptInner();
  }
  
  //*********************************************************************
  // OnFail = (TILDA LWING Name? RWING)? {OnFail} ;
  //*********************************************************************
  function OnFail()
  {
    begin("OnFail");
    OnFail_0();
    sem.OnFail();
    return accept();
  }
  
  //-------------------------------------------------------------------
  // OnFail_0 = TILDA LWING Name? RWING
  //-------------------------------------------------------------------
  function OnFail_0()
  {
    begin("");
    if (!TILDA()) return rejectInner();
    if (!LWING()) return rejectInner();
    Name();
    if (!RWING()) return rejectInner();
    return acceptInner();
  }
  
  //*********************************************************************
  // Name = Letter (Letter / Digit)* Space {Name} ;
  //*********************************************************************
  function Name()
  {
    begin("Name");
    if (!Letter()) return reject();
    while (Name_0()){ };
    Space();
    sem.Name();
    return accept();
  }
  
  //-------------------------------------------------------------------
  // Name_0 = Letter / Digit
  //-------------------------------------------------------------------
  function Name_0()
  {
    begin("");
    if (Letter()) return acceptInner();
    if (Digit()) return acceptInner();
    return rejectInner();
  }
  
  //*********************************************************************
  // DiagName = "<" Char++ ">" Space {DiagName} ;
  //*********************************************************************
  function DiagName()
  {
    begin("DiagName");
    if (!next('<')) return reject();
    if (next('>')) return reject();
    do{
      if (!Char()) return reject();
    }while (!next('>'));
    Space();
    sem.DiagName();
    return accept();
  }
  
  //*********************************************************************
  // StringLit = ["] Char++ ["] Space {StringLit} ;
  //*********************************************************************
  function StringLit()
  {
    begin("StringLit");
    if (!next('"')) return reject();
    if (next('"')) return reject();
    do{
      if (!Char()) return reject();
    }while (!next('"'));
    Space();
    sem.StringLit();
    return accept();
  }
  
  //*********************************************************************
  // CharClass = ("[" / "^[") Char++ "]" Space {CharClass} ;
  //*********************************************************************
  function CharClass()
  {
    begin("CharClass");
    if (!next('[')
     && !next("^[")
     ) return reject();
    if (next(']')) return reject();
    do{
      if (!Char()) return reject();
    }while (!next(']'));
    Space();
    sem.CharClass();
    return accept();
  }
  
  //*********************************************************************
  // Range = "[" Char "-" Char "]" Space {Range} ;
  //*********************************************************************
  function Range()
  {
    begin("Range");
    if (!next('[')) return reject();
    if (!Char()) return reject();
    if (!next('-')) return reject();
    if (!Char()) return reject();
    if (!next(']')) return reject();
    Space();
    sem.Range();
    return accept();
  }
  
  //*********************************************************************
  // Char = Escape {Pass} / ^[\r\n\] {Char} ;
  //*********************************************************************
  function Char()
  {
    begin("Char");
    if (Escape())
    { sem.Pass(); return accept(); }
    if (nextNotIn("\r\n\\"))
    { sem.Char(); return accept(); }
    return reject();
  }
  
  //*********************************************************************
  // Escape = "\u" HexDigit HexDigit HexDigit HexDigit {Unicode} / "\t"
  // {Tab} / "\n" {Newline} / "\r" {CarRet} / !"\u" "\" _ {Escape} ;
  //*********************************************************************
  function Escape()
  {
    begin("Escape");
    if (Escape_0())
    { sem.Unicode(); return accept(); }
    if (next("\\t"))
    { sem.Tab(); return accept(); }
    if (next("\\n"))
    { sem.Newline(); return accept(); }
    if (next("\\r"))
    { sem.CarRet(); return accept(); }
    if (Escape_1())
    { sem.Escape(); return accept(); }
    return reject();
  }
  
  //-------------------------------------------------------------------
  // Escape_0 = "\u" HexDigit HexDigit HexDigit HexDigit
  //-------------------------------------------------------------------
  function Escape_0()
  {
    begin("");
    if (!next("\\u")) return rejectInner();
    if (!HexDigit()) return rejectInner();
    if (!HexDigit()) return rejectInner();
    if (!HexDigit()) return rejectInner();
    if (!HexDigit()) return rejectInner();
    return acceptInner();
  }
  
  //-------------------------------------------------------------------
  // Escape_1 = !"\u" "\" _
  //-------------------------------------------------------------------
  function Escape_1()
  {
    begin("");
    if (!aheadNot("\\u")) return rejectInner();
    if (!next('\\')) return rejectInner();
    if (!next()) return rejectInner();
    return acceptInner();
  }
  
  //*********************************************************************
  // Letter = [a-z] / [A-Z] ;
  //*********************************************************************
  function Letter()
  {
    begin("Letter");
    if (nextIn('a','z')) return accept();
    if (nextIn('A','Z')) return accept();
    return reject();
  }
  
  //*********************************************************************
  // Digit = [0-9] ;
  //*********************************************************************
  function Digit()
  {
    begin("Digit");
    if (!nextIn('0','9')) return reject();
    return accept();
  }
  
  //*********************************************************************
  // HexDigit = [0-9] / [a-f] / [A-F] ;
  //*********************************************************************
  function HexDigit()
  {
    begin("HexDigit");
    if (nextIn('0','9')) return accept();
    if (nextIn('a','f')) return accept();
    if (nextIn('A','F')) return accept();
    return reject();
  }
  
  //*********************************************************************
  // PREFIX = [&!] Space <& or !> ;
  //*********************************************************************
  function PREFIX()
  {
    begin("PREFIX","& or !");
    if (!nextIn("&!")) return reject();
    Space();
    return accept();
  }
  
  //*********************************************************************
  // SUFFIX = [?*+] Space <? or * or +> ;
  //*********************************************************************
  function SUFFIX()
  {
    begin("SUFFIX","? or * or +");
    if (!nextIn("?*+")) return reject();
    Space();
    return accept();
  }
  
  //*********************************************************************
  // UNTIL = ("*+" / "++") Space <*+ or ++> ;
  //*********************************************************************
  function UNTIL()
  {
    begin("UNTIL","*+ or ++");
    if (!next("*+")
     && !next("++")
     ) return reject();
    Space();
    return accept();
  }
  
  //*********************************************************************
  // EQUAL = "=" Space <=> ;
  //*********************************************************************
  function EQUAL()
  {
    begin("EQUAL","=");
    if (!next('=')) return reject();
    Space();
    return accept();
  }
  
  //*********************************************************************
  // SEMI = ";" Space <;> ;
  //*********************************************************************
  function SEMI()
  {
    begin("SEMI",";");
    if (!next(';')) return reject();
    Space();
    return accept();
  }
  
  //*********************************************************************
  // SLASH = "/" Space </> ;
  //*********************************************************************
  function SLASH()
  {
    begin("SLASH","/");
    if (!next('/')) return reject();
    Space();
    return accept();
  }
  
  //*********************************************************************
  // AND = "&" Space <&> ;
  //*********************************************************************
  function AND()
  {
    begin("AND","&");
    if (!next('&')) return reject();
    Space();
    return accept();
  }
  
  //*********************************************************************
  // LPAREN = "(" Space <(> ;
  //*********************************************************************
  function LPAREN()
  {
    begin("LPAREN","(");
    if (!next('(')) return reject();
    Space();
    return accept();
  }
  
  //*********************************************************************
  // RPAREN = ")" Space <)> ;
  //*********************************************************************
  function RPAREN()
  {
    begin("RPAREN",")");
    if (!next(')')) return reject();
    Space();
    return accept();
  }
  
  //*********************************************************************
  // LWING = "{" Space <{> ;
  //*********************************************************************
  function LWING()
  {
    begin("LWING","{");
    if (!next('{')) return reject();
    Space();
    return accept();
  }
  
  //*********************************************************************
  // RWING = "}" Space <}> ;
  //*********************************************************************
  function RWING()
  {
    begin("RWING","}");
    if (!next('}')) return reject();
    Space();
    return accept();
  }
  
  //*********************************************************************
  // TILDA = "~" Space <~> ;
  //*********************************************************************
  function TILDA()
  {
    begin("TILDA","~");
    if (!next('~')) return reject();
    Space();
    return accept();
  }
  
  //*********************************************************************
  // ANY = "_" Space <_> ;
  //*********************************************************************
  function ANY()
  {
    begin("ANY","_");
    if (!next('_')) return reject();
    Space();
    return accept();
  }
  
  //*********************************************************************
  // Space = ([ \r\n\t] / Comment)* {Space} ;
  //*********************************************************************
  function Space()
  {
    begin("Space");
    while (Space_0()){ };
    sem.Space();
    return accept();
  }
  
  //-------------------------------------------------------------------
  // Space_0 = [ \r\n\t] / Comment
  //-------------------------------------------------------------------
  function Space_0()
  {
    begin("");
    if (nextIn(" \r\n\t")) return acceptInner();
    if (Comment()) return acceptInner();
    return rejectInner();
  }
  
  //*********************************************************************
  // Comment = "//" _*+ EOL ;
  //*********************************************************************
  function Comment()
  {
    begin("Comment");
    if (!next("//")) return reject();
    while (!EOL()){
      if (!next()) return reject();
    }
    return accept();
  }
  
  //*********************************************************************
  // EOL = [\r]? [\n] / !_ <end of line> ;
  //*********************************************************************
  function EOL()
  {
    begin("EOL","end of line");
    if (EOL_0()) return accept();
    if (EOL_1()) return accept();
    return reject();
  }
  
  //-------------------------------------------------------------------
  // EOL_0 = [\r]? [\n]
  //-------------------------------------------------------------------
  function EOL_0()
  {
    begin("");
    next('\r');
    if (!next('\n')) return rejectInner();
    return acceptInner();
  }
  
  //-------------------------------------------------------------------
  // EOL_1 = !_
  //-------------------------------------------------------------------
  function EOL_1()
  {
    begin("","end of text");
    if (next()) return rejectPred();
    return acceptPred();
  }
  
  //*********************************************************************
  // EOT = !_ <end of text> ;
  //*********************************************************************
  function EOT()
  {
    begin("EOT","end of text");
    if (!aheadNot()) return reject();
    return accept();
  }
  
}
